# -*- coding: utf-8 -*-
"""Assignment oops Module 5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1shmfRX7OYRcWq2t3Us8TEt5XJ1cLFMQ_

# Q 1  What are the five key concepts of Object-Oriented Programming (OOP)?
"""



"""The five key concepts of Object-Oriented Programming (OOP) are:

Encapsulation: Bundling the data (attributes) and methods (functions) that operate on the data into a single unit or class, and restricting access to some of the object's components to ensure controlled interaction.

Abstraction: Hiding the complex implementation details and exposing only the necessary parts. This allows users to interact with the object at a high level without needing to understand the internal workings.

Inheritance: A mechanism where one class (child class) can inherit attributes and methods from another class (parent class), promoting code reuse and creating a hierarchical relationship between classes.

Polymorphism: Allowing objects to be treated as instances of their parent class, enabling one function or method to operate in different ways depending on the object it is acting upon.

Classes and Objects: A class defines a blueprint for creating objects (instances), which hold the data and behavior. An object is an instance of a class and represents a real-world entity with attributes (data) and behaviors (methods).

# Write a Python class for a `Car` with attributes for `make`, `model`, and `year`. Include a method to display
"""

class Car:
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year

    def display_info(self):
        print(f"Car Information: {self.year} {self.make} {self.model}")

# Example usage
my_car = Car("Toyota", "Camry", 2020)
my_car.display_info()

"""# Q 3  Explain the difference between instance methods and class methods. Provide an example of each

In Python, instance methods and class methods differ in how they interact with the class and its instances:

1. Instance Methods:
Definition: Instance methods operate on the instance (object) of the class. They can access and modify instance attributes.
How they are called: They are called on objects (instances of a class) and use self to refer to the object they are operating on.
2. Class Methods:
Definition: Class methods operate on the class itself, not the instance. They can modify class-level attributes or provide functionality related to the class as a whole. They do not interact with instance-specific data but with class-wide data.
How they are called: They are called on the class itself and use cls to refer to the class. Class methods are defined using the @classmethod decorator.
"""

class Car:
    # Class attribute
    car_count = 0

    def __init__(self, make, model, year):
        # Instance attributes
        self.make = make
        self.model = model
        self.year = year
        Car.car_count += 1

    # Instance method
    def display_info(self):
        print(f"Car Information: {self.year} {self.make} {self.model}")

    # Class method
    @classmethod
    def total_cars(cls):
        print(f"Total number of cars: {cls.car_count}")

# Example usage
car1 = Car("Toyota", "Camry", 2020)
car2 = Car("Honda", "Civic", 2019)

# Calling instance method
car1.display_info()  # Outputs: Car Information: 2020 Toyota Camry

# Calling class method
Car.total_cars()     # Outputs: Total number of cars: 2

"""# Q4 . How does Python implement method overloading? Give an example.

Python does not support traditional method overloading like other languages (e.g., Java or C++) where multiple methods with the same name but different parameters exist. In Python, a method can only have one definition with a specific name in a class. If you define the method again, it will overwrite the previous definition.

However, Python achieves similar functionality through default arguments or by using *args and **kwargs to handle varying numbers of arguments. You can also check argument types within the method to simulate overloading behavior.
"""

# Example using default arguments:
class Calculator:
    # Simulating overloading using default arguments
    def add(self, a, b=0, c=0):
        return a + b + c

# Example usage
calc = Calculator()

print(calc.add(10))        # Outputs: 10 (using one argument)
print(calc.add(10, 20))    # Outputs: 30 (using two arguments)
print(calc.add(10, 20, 30))# Outputs: 60 (using three arguments)

# Example using *args for flexibility:
class Calculator:
    # Simulating overloading using *args
    def add(self, *args):
        return sum(args)

# Example usage
calc = Calculator()

print(calc.add(10))        # Outputs: 10 (with one argument)
print(calc.add(10, 20))    # Outputs: 30 (with two arguments)
print(calc.add(10, 20, 30))# Outputs: 60 (with three arguments)

"""In this example, the add method accepts a variable number of arguments using *args, achieving flexibility similar to method overloading.

Key Points:
Python does not support true method overloading (i.e., multiple methods with the same name but different signatures).
Instead, use default arguments or *args and **kwargs to allow methods to accept varying numbers or types of arguments.

# Q 5 What are the three types of access modifiers in Python? How are they denoted?

In Python, access modifiers control the accessibility of class attributes and methods. Python uses naming conventions to define these access levels, but unlike some other languages (like Java or C++), Python does not enforce strict access control. Instead, it relies on conventions to indicate how an attribute or method should be accessed.

The three types of access modifiers in Python are:
Public:

Denotation: No underscores before the attribute or method name.
Description: Public members can be accessed from anywhere, both inside and outside the class. This is the default access level in Python.
"""

class MyClass:
    def __init__(self):
        self.public_attribute = "I am public"

obj = MyClass()
print(obj.public_attribute)  # Accessible

"""Protected:

Denotation: A single underscore (_) before the attribute or method name.
Description: Protected members are intended to be accessed only within the class and its subclasses. This is more of a convention, as Python does not enforce it. It is still possible to access protected members from outside the class.

"""

class MyClass:
    def __init__(self):
        self._protected_attribute = "I am protected"

obj = MyClass()
print(obj._protected_attribute)  # Accessible but should be treated as protected

"""Private:

Denotation: A double underscore (__) before the attribute or method name.
Description: Private members are intended to be inaccessible from outside the class. Python implements name mangling, which changes the name of the private variable to include the class name, making it more difficult to access. However, it is still possible to access private members using a modified name.

"""

class MyClass:
    def __init__(self):
        self.__private_attribute = "I am private"

obj = MyClass()
# print(obj.__private_attribute)  # This will raise an AttributeError

# Accessing via name mangling
print(obj._MyClass__private_attribute)  # Still accessible using name mangling

"""Public: No underscore (public_var) — accessible from anywhere.
Protected: Single underscore (_protected_var) — should be accessed only within the class and its subclasses.
Private: Double underscore (__private_var) — intended to be inaccessible outside the class but can be accessed using name mangling.

# Q 6  Describe the five types of inheritance in Python. Provide a simple example of multiple inheritance.

In Python, inheritance allows a class to inherit attributes and methods from another class, facilitating code reuse and logical hierarchy. There are five types of inheritance:

1. Single Inheritance:
A class inherits from only one parent class.
"""

class Animal:
    def speak(self):
        print("Animal speaks")

class Dog(Animal):
    def bark(self):
        print("Dog barks")

d = Dog()
d.speak()  # Inherited from Animal class
d.bark()

"""2. Multiple Inheritance:
A class can inherit from more than one parent class.

"""

class Father:
    def work(self):
        print("Father works")

class Mother:
    def care(self):
        print("Mother cares")

class Child(Father, Mother):
    def play(self):
        print("Child plays")

c = Child()
c.work()  # Inherited from Father
c.care()  # Inherited from Mother
c.play()

"""3. Multilevel Inheritance:
A class inherits from a parent class, which in turn inherits from another class, forming a chain of inheritance.
"""

class Grandparent:
    def wisdom(self):
        print("Grandparent's wisdom")

class Parent(Grandparent):
    def experience(self):
        print("Parent's experience")

class Child(Parent):
    def energy(self):
        print("Child's energy")

c = Child()
c.wisdom()      # Inherited from Grandparent
c.experience()  # Inherited from Parent
c.energy()

"""4. Hierarchical Inheritance:
Multiple classes inherit from the same parent class.
"""

class Animal:
    def eat(self):
        print("Animal eats")

class Dog(Animal):
    def bark(self):
        print("Dog barks")

class Cat(Animal):
    def meow(self):
        print("Cat meows")

d = Dog()
c = Cat()

d.eat()  # Inherited from Animal
d.bark()

c.eat()  # Inherited from Animal
c.meow()

"""Hybrid Inheritance:
A combination of two or more types of inheritance, typically a mix of hierarchical and multiple inheritance.
"""

class Animal:
    def eat(self):
        print("Animal eats")

class Dog(Animal):
    def bark(self):
        print("Dog barks")

class Cat(Animal):
    def meow(self):
        print("Cat meows")

class Pet(Dog, Cat):
    def play(self):
        print("Pet plays")

p = Pet()
p.eat()   # Inherited from Animal
p.bark()  # Inherited from Dog
p.meow()  # Inherited from Cat
p.play()

"""Example of Multiple Inheritance:"""

class Father:
    def work(self):
        print("Father works")

class Mother:
    def care(self):
        print("Mother cares")

class Child(Father, Mother):
    def play(self):
        print("Child plays")

# Example usage
c = Child()
c.work()  # From Father
c.care()  # From Mother
c.play()  # From Child

"""# Q 7  What is the Method Resolution Order (MRO) in Python? How can you retrieve it programmatically?

Method Resolution Order (MRO) in Python:
The Method Resolution Order (MRO) is the order in which Python looks for a method in a hierarchy of classes. When a method is called on an instance, Python searches for the method starting from the instance's class, then moves through the parent classes in the order specified by the MRO.

MRO is especially important in the context of multiple inheritance to ensure that methods are inherited from the correct classes and avoid ambiguity.

Python uses the C3 Linearization (C3 superclass linearization) algorithm to determine the MRO. This ensures a consistent order when dealing with complex inheritance hierarchies.

How to retrieve MRO programmatically:
You can retrieve the MRO using the following methods:

ClassName.mro(): Returns a list of the classes in the MRO.
ClassName.__mro__: A tuple containing the MRO.
help(ClassName): This prints detailed information about the class, including its MRO.
Example:
"""

class A:
    def process(self):
        print("Class A")

class B(A):
    def process(self):
        print("Class B")

class C(A):
    def process(self):
        print("Class C")

class D(B, C):
    pass

# Retrieve MRO
print(D.mro())         # Using mro() method
print(D.__mro__)       # Using __mro__ attribute

# Calling a method to observe MRO in action
d = D()
d.process()  # Will follow the MRO to find the method

"""In this example:

The MRO for class D is: D -> B -> C -> A -> object.
When calling d.process(), Python first looks in class D, then B, and finds the method in B before reaching C or A.
Key points about MRO:
Multiple inheritance: MRO ensures that Python correctly resolves method calls when multiple inheritance is used.
C3 linearization: Python ensures that the order of method resolution is consistent with a depth-first search but respects inheritance hierarchies.

# Q 8 Create an abstract base class `Shape` with an abstract method `area()`. Then create two subclasses
`Circle` and `Rectangle` that implement the `area()` method.

To create an abstract base class in Python, you can use the ABC (Abstract Base Class) module from the abc package. An abstract base class is a class that contains one or more abstract methods that must be implemented by subclasses. Here's an example with Shape as the abstract base class and Circle and Rectangle as subclasses implementing the area() method.
"""

from abc import ABC, abstractmethod
import math

# Abstract base class
class Shape(ABC):

    @abstractmethod
    def area(self):
        pass  # Abstract method, must be implemented by subclasses

# Subclass Circle
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    # Implementing the abstract method
    def area(self):
        return math.pi * self.radius ** 2

# Subclass Rectangle
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    # Implementing the abstract method
    def area(self):
        return self.width * self.height

# Example usage
circle = Circle(5)  # Circle with radius 5
rectangle = Rectangle(4, 6)  # Rectangle with width 4 and height 6

print(f"Circle Area: {circle.area()}")       # Outputs: Circle Area: 78.53981633974483
print(f"Rectangle Area: {rectangle.area()}")  # Outputs: Rectangle Area: 24

"""Explanation:
Abstract Class (Shape):

The Shape class is defined as an abstract base class by inheriting from ABC.
The @abstractmethod decorator is used to define area() as an abstract method that must be implemented by any subclass of Shape.
Subclass Circle:

The Circle class implements the area() method, calculating the area using the formula for the area of a circle: π * r^2.
Subclass Rectangle:

The Rectangle class implements the area() method, calculating the area using the formula for the area of a rectangle: width * height.
Usage:

We create instances of Circle and Rectangle and call their area() methods to compute the area based on the specific shape.

# Q 9 . Demonstrate polymorphism by creating a function that can work with different shape objects to calculate
and print their areas.

Polymorphism allows a function to work with objects of different types that share a common interface. In this case, we can demonstrate polymorphism by creating a function that works with different shape objects (like Circle and Rectangle) and calculates their areas, even though the objects belong to different classes.

Example:
"""

from abc import ABC, abstractmethod
import math

# Abstract base class
class Shape(ABC):

    @abstractmethod
    def area(self):
        pass

# Subclass Circle
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius ** 2

# Subclass Rectangle
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

# Subclass Triangle
class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height

    def area(self):
        return 0.5 * self.base * self.height

# Polymorphic function
def print_area(shape: Shape):
    print(f"The area of the shape is: {shape.area()}")

# Example usage
circle = Circle(5)        # Circle with radius 5
rectangle = Rectangle(4, 6)  # Rectangle with width 4 and height 6
triangle = Triangle(3, 8)  # Triangle with base 3 and height 8

# Using the polymorphic function to calculate areas
print_area(circle)    # Works with Circle
print_area(rectangle) # Works with Rectangle
print_area(triangle)  # Works with Triangle

"""Explanation:
Polymorphism: The print_area() function demonstrates polymorphism. It accepts any object of type Shape (or its subclasses) and calls the area() method, regardless of whether the object is a Circle, Rectangle, or Triangle.

Polymorphic behavior: Each shape class (Circle, Rectangle, Triangle) implements the area() method in its own way. When the print_area() function is called, the correct method for each shape is automatically executed.

Reusability: This approach allows the print_area() function to be reusable for any future shape classes that implement the Shape interface, making the code flexible and extensible.

By using polymorphism, the print_area() function can work with any object that is a subclass of Shape, enabling it to handle different shapes seamlessly.

# Q 10 Implement encapsulation in a `BankAccount` class with private attributes for `balance` and
`account_number`. Include methods for deposit, withdrawal, and balance inquiry.

To implement encapsulation in a BankAccount class, we need to define private attributes for sensitive data like balance and account_number. These private attributes will be accessible only through public methods, which control how the data is modified or accessed.

We use double underscores (__) to denote private attributes, and then provide public methods for depositing money, withdrawing money, and checking the balance.

Code Example:
"""

class BankAccount:
    def __init__(self, account_number, initial_balance=0):
        self.__account_number = account_number  # Private attribute
        self.__balance = initial_balance         # Private attribute

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"Deposited: ${amount:.2f}. New balance: ${self.__balance:.2f}.")
        else:
            print("Deposit amount must be positive.")

    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            print(f"Withdrew: ${amount:.2f}. New balance: ${self.__balance:.2f}.")
        else:
            print("Withdrawal amount must be positive and cannot exceed the balance.")

    def get_balance(self):
        return self.__balance

    def get_account_number(self):
        return self.__account_number


# Example usage
account = BankAccount("123456789", 1000)  # Creating an account with account number and initial balance

# Perform operations
account.deposit(500)            # Depositing money
account.withdraw(200)           # Withdrawing money
print(f"Account Balance: ${account.get_balance():.2f}")  # Checking balance
print(f"Account Number: {account.get_account_number()}")  # Checking account number

"""Explanation:
Private Attributes:

The attributes __account_number and __balance are declared as private by prefixing them with double underscores (__). This restricts access to these attributes from outside the class.
Public Methods:

deposit(amount): Allows depositing money into the account. It checks if the amount is positive before updating the balance.
withdraw(amount): Allows withdrawing money from the account. It checks if the amount is positive and does not exceed the current balance.
get_balance(): Returns the current balance of the account.
get_account_number(): Returns the account number, providing controlled access to the private attribute.
Example Usage: The example shows how to create a BankAccount object and perform deposit and withdrawal operations, demonstrating encapsulation. Users interact with the account through methods rather than directly accessing the attributes, promoting safe and controlled access to the account's data.

# Q 11  Write a class that overrides the `__str__` and `__add__` magic methods. What will these methods allow
you to do?

In Python, magic methods (also known as dunder methods) allow you to define how your objects behave with built-in functions and operators. The __str__ method is used to define a string representation of an object, while the __add__ method allows you to define the behavior of the addition operator (+) for instances of your class.

Example Class Implementation:
Let's create a class called Vector that represents a mathematical vector in two-dimensional space. We will override the __str__ method to provide a readable string representation of the vector, and we will override the __add__ method to allow the addition of two vectors.
"""

class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        # This method defines the string representation of the object
        return f"Vector({self.x}, {self.y})"

    def __add__(self, other):
        # This method allows the addition of two Vector objects
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        return NotImplemented

# Example usage
v1 = Vector(2, 3)
v2 = Vector(5, 7)

# Using __str__ method
print(v1)  # Outputs: Vector(2, 3)
print(v2)  # Outputs: Vector(5, 7)

# Using __add__ method
v3 = v1 + v2
print(v3)  # Outputs: Vector(7, 10)

"""Explanation:
__init__ Method: The constructor initializes the vector with x and y coordinates.

__str__ Method:

This method provides a user-friendly string representation of the vector. When you use the print() function on a Vector instance or convert it to a string, this method is called. In the example, calling print(v1) outputs Vector(2, 3) instead of the default representation.
__add__ Method:

This method allows the use of the + operator with Vector objects. When you add two Vector instances (e.g., v1 + v2), this method is invoked. The method checks if the other object is an instance of Vector, and if so, it returns a new Vector instance that represents the sum of the two vectors. If other is not a Vector, it returns NotImplemented, which allows Python to handle the operation gracefully (e.g., by raising a TypeError).
Output:

# Q 12 . Create a decorator that measures and prints the execution time of a function.

You can create a decorator in Python to measure and print the execution time of a function by using the time module. A decorator is a function that takes another function as an argument and extends its behavior without modifying its code.

Example Decorator:
Here's how you can implement a decorator called execution_time to measure the execution time of a function:
"""

import time

def execution_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()  # Record the start time
        result = func(*args, **kwargs)  # Call the original function
        end_time = time.time()  # Record the end time
        elapsed_time = end_time - start_time  # Calculate the elapsed time
        print(f"Execution time: {elapsed_time:.4f} seconds")
        return result  # Return the result of the original function
    return wrapper

# Example usage of the decorator
@execution_time
def slow_function():
    time.sleep(2)  # Simulate a slow function by sleeping for 2 seconds
    print("Function finished.")

# Calling the decorated function
slow_function()

"""Explanation:
Importing the Time Module: The time module is imported to measure the time.

Creating the Decorator:

execution_time(func) is the decorator function that takes another function (func) as an argument.
Inside it, we define an inner function wrapper(*args, **kwargs) that will wrap the original function.
Measuring Execution Time:

The start_time is recorded before calling the original function.
The original function is called with its arguments (*args and **kwargs).
The end_time is recorded after the function call.
The elapsed time is calculated as end_time - start_time, and it's printed.
Returning the Result: The result of the original function is returned from the wrapper.

Using the Decorator: The @execution_time syntax is used to decorate the slow_function. When slow_function() is called, it will now print the execution time.

# Q 13 Explain the concept of the Diamond Problem in multiple inheritance. How does Python resolve it?

The Diamond Problem is a common issue that arises in multiple inheritance scenarios in object-oriented programming. It occurs when a class inherits from two classes that have a common ancestor, leading to ambiguity about which parent's methods or attributes should be inherited by the child class.

Diamond Problem Explained:
Here's a visual representation of the Diamond Problem:

How Python Resolves the Diamond Problem:
Python uses a method resolution order (MRO) to address the Diamond Problem. The MRO is determined using the C3 Linearization algorithm, which provides a consistent order of method resolution in cases of multiple inheritance. This ensures that the hierarchy is resolved in a way that maintains the order of inheritance and avoids ambiguity.

MRO Example:
Let's illustrate this with an example:
"""

class A:
    def greet(self):
        print("Hello from A")

class B(A):
    def greet(self):
        print("Hello from B")

class C(A):
    def greet(self):
        print("Hello from C")

class D(B, C):
    pass

# Create an instance of D
d = D()
d.greet()  # Outputs: Hello from B

"""MRO Resolution:
When d.greet() is called, Python checks the MRO for class D.
The MRO for class D is determined as D -> B -> C -> A.
Python finds the greet() method in class B first, so it calls that method, outputting: Hello from B.
Checking MRO Programmatically:
You can view the MRO of a class in Python using the mro() method or the __mro__ attribute:
"""

print(D.mro())        # Outputs: [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
print(D.__mro__)      # Same output as mro()

"""The Diamond Problem arises in multiple inheritance when a class inherits from two classes that share a common base class, leading to ambiguity about which method to invoke.
Python resolves this problem using the C3 Linearization algorithm to determine the Method Resolution Order (MRO), ensuring a clear and consistent order of inheritance.
The MRO allows Python to decide which method to call when there are multiple potential candidates from parent classes, thereby avoiding ambiguity and maintaining a predictable behavior in class hierarchies.

# Q 14 Write a class method that keeps track of the number of instances created from a class.

To keep track of the number of instances created from a class, you can use a class variable that increments every time a new instance is created. You can implement this using a class method. Below is an example of a class called InstanceCounter that tracks the number of instances created.

Example Implementation:
"""

class InstanceCounter:
    instance_count = 0  # Class variable to keep track of the number of instances

    def __init__(self):
        InstanceCounter.instance_count += 1  # Increment the count on each instance creation

    @classmethod
    def get_instance_count(cls):
        """Class method to get the number of instances created."""
        return cls.instance_count

# Example usage
if __name__ == "__main__":
    obj1 = InstanceCounter()
    obj2 = InstanceCounter()
    obj3 = InstanceCounter()

    # Retrieve the count of instances created
    print(f"Number of instances created: {InstanceCounter.get_instance_count()}")  # Outputs: 3

"""Explanation:
Class Variable: The variable instance_count is defined as a class variable, which is shared among all instances of the class. This variable is used to keep track of the total number of instances created.

__init__ Method: In the constructor (__init__), we increment the instance_count by 1 each time a new instance of InstanceCounter is created.

Class Method: The method get_instance_count() is defined as a class method using the @classmethod decorator. This method returns the current value of instance_count.

Example Usage: When instances of InstanceCounter are created (three instances in this case), the instance count is incremented. The final print statement retrieves and displays the total number of instances created.

Output:
When you run the example code, the output will be:
This demonstrates that the class method successfully tracks the number of instances created from the InstanceCounter class.

# Q 15 Implement a static method in a class that checks if a given year is a leap year.

You can implement a static method in a class to check if a given year is a leap year. A year is considered a leap year if:

It is divisible by 4.
It is not divisible by 100, unless it is also divisible by 400.
Here's an example implementation in Python:

Example Implementation:
"""

class YearUtils:
    @staticmethod
    def is_leap_year(year):
        """Check if the given year is a leap year."""
        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
            return True
        return False

# Example usage
if __name__ == "__main__":
    year_to_check = 2024
    if YearUtils.is_leap_year(year_to_check):
        print(f"{year_to_check} is a leap year.")
    else:
        print(f"{year_to_check} is not a leap year.")

"""Explanation:
Static Method: The method is_leap_year(year) is defined as a static method using the @staticmethod decorator. This means it does not require an instance of the class to be called and does not have access to self or cls.

Leap Year Logic: The method implements the logic to check whether the given year is a leap year:

If the year is divisible by 4 and not divisible by 100, or if it is divisible by 400, it returns True.
Otherwise, it returns False.
Example Usage: In the main block, you can check whether a specific year (in this case, 2024) is a leap year by calling the static method directly on the class YearUtils.
"""

